/* SPDX-License-Identifier: (Apache-2.0 OR MIT OR Zlib) */
/* Copyright Â© 2021 Violet Leonard */

#![allow(missing_docs)]

use std::rc::Rc;

use super::{stdshaders::Shaders, texture::TextureCache};

pub const DEBUG: bool = option_env!("SUZY_GL_DEBUG").is_some();

pub mod bindings {
    #![allow(bare_trait_objects)]
    #![allow(clippy::too_many_arguments)]
    #![allow(clippy::unused_unit)]
    #![allow(clippy::upper_case_acronyms)]
    #![allow(clippy::missing_safety_doc)]

    // This file was generated by the gl_generator crate, but is included
    // statically for performance reasons

    include!("opengl_bindings.rs");
}

pub type OpenGlBindings = bindings::Gles2;

pub struct OpenGlContext {
    pub(super) bindings: Rc<OpenGlBindings>,
    pub(super) shaders: Shaders,
    pub(super) texture_cache: TextureCache,
    pub(super) buffers: Vec<bindings::types::GLuint>,
}

impl OpenGlContext {
    pub fn new<F>(loader: F) -> Self
    where
        F: FnMut(&str) -> *const std::ffi::c_void,
    {
        let ptr = Rc::new(OpenGlBindings::load_with(loader));
        if DEBUG && ptr.DebugMessageCallback.is_loaded() {
            unsafe {
                ptr.Enable(bindings::DEBUG_OUTPUT);
                ptr.DebugMessageCallback(
                    Self::message_callback,
                    std::ptr::null(),
                );
            }
        }
        let shaders = Shaders::new(&ptr).expect("Failed to compile shaders");
        Self {
            bindings: ptr,
            shaders,
            texture_cache: TextureCache::default(),
            buffers: Vec::new(),
        }
    }

    pub fn run_texture_populators(&mut self) {
        self.texture_cache.run_populators(&self.bindings);
    }

    #[allow(clippy::print_stdout)]
    extern "system" fn message_callback(
        _source: bindings::types::GLenum,
        _gltype: bindings::types::GLenum,
        _id: bindings::types::GLuint,
        _severity: bindings::types::GLenum,
        length: bindings::types::GLsizei,
        message: *const bindings::types::GLchar,
        _user_param: *mut std::ffi::c_void,
    ) {
        let data = unsafe {
            std::slice::from_raw_parts(message as *const u8, length as usize)
        };
        println!("{}", String::from_utf8_lossy(data));
    }
}
